// Service Worker cho KimiZK-Translator (Manifest V3)
const CURRENT_VERSION = chrome.runtime.getManifest().version;
const GITHUB_RELEASES_URL = 'https://api.github.com/repos/KimiZK-Dev/KimiZK-Translator/releases/latest';

// Check for updates every 6 hours
const UPDATE_CHECK_INTERVAL = 6 * 60 * 60 * 1000; // 6 hours in milliseconds

// ƒê·∫£m b·∫£o service worker ƒë∆∞·ª£c k√≠ch ho·∫°t
console.log('KimiZK-Translator Service Worker loading... Version:', CURRENT_VERSION);

// ƒê·∫£m b·∫£o service worker ƒë∆∞·ª£c k√≠ch ho·∫°t
self.addEventListener('install', (event) => {
    console.log('Service Worker installed');
});

self.addEventListener('activate', (event) => {
    console.log('Service Worker activated');
});

// Test listener ƒë∆°n gi·∫£n
chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {
    console.log('Message received:', request.action);
    
    if (request.action === "saveApiKey") {
        chrome.storage.local.set({ API_KEY: request.key }, () => {
            if (chrome.runtime.lastError) {
                sendResponse({ success: false, error: chrome.runtime.lastError.message });
            } else {
                sendResponse({ success: true });
            }
        });
        return true; // Gi·ªØ k·∫øt n·ªëi cho async response
    }
    
    if (request.action === "test") {
        console.log('Test message received');
        sendResponse({ success: true, message: 'Service worker is working', version: CURRENT_VERSION });
        return true;
    }
    
    if (request.action === "checkForUpdates") {
        console.log('Manual update check requested');
        checkForUpdates().then(updateInfo => {
            console.log('Manual update check result:', updateInfo);
            // Hi·ªÉn th·ªã modal n·∫øu c√≥ c·∫≠p nh·∫≠t, th√¥ng b√°o n·∫øu kh√¥ng
            if (updateInfo.hasUpdate) {
                chrome.tabs.query({}, (tabs) => {
                    tabs.forEach(tab => {
                        chrome.tabs.sendMessage(tab.id, {
                            action: "showUpdateModal",
                            updateInfo: updateInfo
                        }).catch((error) => {
                            console.log('Failed to send update modal to tab', tab.id, ':', error);
                        });
                    });
                });
            } else if (updateInfo.latestVersion) {
                showUpdateNotification(
                    'üìã Th√¥ng tin phi√™n b·∫£n', 
                    `Phi√™n b·∫£n m·ªõi nh·∫•t tr√™n GitHub: ${updateInfo.releaseName || `KimiZK-Translator v${updateInfo.latestVersion}`}`
                );
            }
            sendResponse(updateInfo);
        }).catch(error => {
            console.error('Error in checkForUpdates:', error);
            sendResponse({ 
                hasUpdate: false, 
                error: error.message,
                currentVersion: CURRENT_VERSION,
                message: "L·ªói khi ki·ªÉm tra c·∫≠p nh·∫≠t: " + error.message
            });
        });
        return true;
    }
    
    if (request.action === "performUpdate") {
        performUpdate().then(result => {
            sendResponse(result);
        });
        return true;
    }
    
    if (request.action === "getLatestVersion") {
        console.log('Getting latest version info from GitHub');
        checkForUpdates().then(updateInfo => {
            console.log('Latest version info:', updateInfo);
            // Hi·ªÉn th·ªã modal n·∫øu c√≥ c·∫≠p nh·∫≠t, th√¥ng b√°o n·∫øu kh√¥ng
            if (updateInfo.hasUpdate) {
                chrome.tabs.query({}, (tabs) => {
                    tabs.forEach(tab => {
                        chrome.tabs.sendMessage(tab.id, {
                            action: "showUpdateModal",
                            updateInfo: updateInfo
                        }).catch((error) => {
                            console.log('Failed to send update modal to tab', tab.id, ':', error);
                        });
                    });
                });
            } else if (updateInfo.latestVersion) {
                showUpdateNotification(
                    'üìã Phi√™n b·∫£n m·ªõi nh·∫•t tr√™n GitHub', 
                    `${updateInfo.releaseName || `KimiZK-Translator v${updateInfo.latestVersion}`} - ƒêang s·ª≠ d·ª•ng phi√™n b·∫£n m·ªõi nh·∫•t`
                );
            }
            sendResponse(updateInfo);
        }).catch(error => {
            console.error('Error getting latest version:', error);
            sendResponse({ 
                error: error.message,
                currentVersion: CURRENT_VERSION,
                message: "Kh√¥ng th·ªÉ l·∫•y th√¥ng tin phi√™n b·∫£n m·ªõi nh·∫•t: " + error.message
            });
        });
        return true;
    }
    
    // Default response for unknown actions
    console.log('Unknown action:', request.action);
    sendResponse({ error: 'Unknown action' });
    return false;
});

// X·ª≠ l√Ω c√†i ƒë·∫∑t v√† c·∫≠p nh·∫≠t extension - ƒê√£ ƒë∆∞·ª£c di chuy·ªÉn l√™n tr√™n

// X·ª≠ l√Ω khi service worker ƒë∆∞·ª£c k√≠ch ho·∫°t
chrome.runtime.onStartup.addListener(() => {
    console.log('KimiZK-Translator Service Worker started');
    // Check update ngay khi kh·ªüi ƒë·ªông
    setTimeout(() => {
        checkForUpdatesOnStartup();
        scheduleUpdateCheck();
    }, 2000); // Delay 2 gi√¢y ƒë·ªÉ ƒë·∫£m b·∫£o browser ƒë√£ s·∫µn s√†ng
});

// Th√™m listener cho khi tab ƒë∆∞·ª£c t·∫°o m·ªõi
chrome.tabs.onCreated.addListener((tab) => {
    // Ki·ªÉm tra c·∫≠p nh·∫≠t khi tab m·ªõi ƒë∆∞·ª£c t·∫°o (ng·∫ßm)
    setTimeout(() => {
        chrome.storage.local.get(['lastUpdateCheck', 'updateReminderTime'], (result) => {
            const now = Date.now();
            const lastCheck = result.lastUpdateCheck || 0;
            const reminderTime = result.updateReminderTime || 0;
            
            // Ki·ªÉm tra n·∫øu ƒë√£ qua 6 gi·ªù ho·∫∑c reminder time ƒë√£ ƒë·∫øn
            if ((now - lastCheck > UPDATE_CHECK_INTERVAL) || (now > reminderTime)) {
                console.log('Checking for updates on new tab creation...');
                checkForUpdates().then(updateInfo => {
                    if (updateInfo.hasUpdate) {
                        // G·ª≠i modal c·∫≠p nh·∫≠t ƒë·∫øn tab m·ªõi
                        setTimeout(() => {
                            chrome.tabs.sendMessage(tab.id, {
                                action: "showUpdateModal",
                                updateInfo: updateInfo
                            }).catch((error) => {
                                console.log('Failed to send update modal to new tab:', error);
                            });
                        }, 3000); // Delay 3 gi√¢y ƒë·ªÉ tab load xong
                    }
                }).catch(error => {
                    console.error('Error checking updates on new tab:', error);
                });
            }
        });
    }, 1000);
});

// Th√™m listener cho khi extension ƒë∆∞·ª£c c√†i ƒë·∫∑t/c·∫≠p nh·∫≠t
chrome.runtime.onInstalled.addListener((details) => {
    console.log('KimiZK-Translator Service Worker installed/updated:', details.reason);
    
    if (details.reason === 'install') {
        // M·ªü trang h∆∞·ªõng d·∫´n khi c√†i ƒë·∫∑t l·∫ßn ƒë·∫ßu
        chrome.tabs.create({
            url: 'https://github.com/KimiZK-Dev/KimiZK-Translator#readme'
        });
        
        // Hi·ªÉn th·ªã th√¥ng b√°o ch√†o m·ª´ng
        showUpdateNotification(
            'üéâ Ch√†o m·ª´ng ƒë·∫øn v·ªõi KimiZK-Translator!', 
            `Phi√™n b·∫£n ${CURRENT_VERSION} v·ªõi Auto-update, h·ªó tr·ª£ 13+ ng√¥n ng·ªØ, UI hi·ªán ƒë·∫°i, Manifest V3. H√£y c·∫•u h√¨nh Groq API key ƒë·ªÉ b·∫Øt ƒë·∫ßu!`
        );
        
        // L∆∞u th·ªùi gian c√†i ƒë·∫∑t
        chrome.storage.local.set({ 
            installTime: Date.now(),
            lastUpdateCheck: Date.now(),
            currentVersion: CURRENT_VERSION
        });
    }
    
    if (details.reason === 'update') {
        // Hi·ªÉn th·ªã th√¥ng b√°o c·∫≠p nh·∫≠t th√†nh c√¥ng
        showUpdateNotification(
            'üéâ C·∫≠p nh·∫≠t th√†nh c√¥ng!', 
            `KimiZK-Translator ƒë√£ ƒë∆∞·ª£c c·∫≠p nh·∫≠t l√™n phi√™n b·∫£n ${CURRENT_VERSION}.`
        );
        
        // L∆∞u th·ªùi gian c·∫≠p nh·∫≠t
        chrome.storage.local.set({ 
            lastUpdateTime: Date.now(),
            currentVersion: CURRENT_VERSION
        });
    }
    
    // Ki·ªÉm tra c·∫≠p nh·∫≠t ngay sau khi c√†i ƒë·∫∑t/c·∫≠p nh·∫≠t
    setTimeout(() => {
        checkForUpdatesOnStartup();
    }, 3000);
});

// Ki·ªÉm tra c·∫≠p nh·∫≠t ngay khi kh·ªüi ƒë·ªông
function checkForUpdatesOnStartup() {
    console.log('=== Starting update check on startup ===');
    
    chrome.storage.local.get(['updateNotifications', 'lastUpdateCheck'], (result) => {
        const notificationsEnabled = result.updateNotifications !== false; // M·∫∑c ƒë·ªãnh b·∫≠t
        const now = Date.now();
        const lastCheck = result.lastUpdateCheck || 0;
        
        console.log('Notifications enabled:', notificationsEnabled);
        console.log('Last check time:', new Date(lastCheck));
        console.log('Current time:', new Date(now));
        console.log('Time since last check:', now - lastCheck, 'ms');
        
        if (notificationsEnabled) {
            console.log('Checking for updates on startup...');
            checkForUpdates().then(updateInfo => {
                console.log('Update check result:', updateInfo);
                
                // Lu√¥n hi·ªÉn th·ªã th√¥ng tin phi√™n b·∫£n m·ªõi nh·∫•t t·ª´ GitHub
                console.log('Startup version info:', updateInfo);
                
                // L∆∞u th·ªùi gian check
                chrome.storage.local.set({ lastUpdateCheck: now });
                
                // Hi·ªÉn th·ªã modal c·∫≠p nh·∫≠t n·∫øu c√≥ phi√™n b·∫£n m·ªõi
                if (updateInfo.hasUpdate) {
                    chrome.tabs.query({}, (tabs) => {
                        console.log('Found tabs:', tabs.length);
                        tabs.forEach(tab => {
                            console.log('Sending update modal to tab:', tab.id);
                            chrome.tabs.sendMessage(tab.id, {
                                action: "showUpdateModal",
                                updateInfo: updateInfo
                            }).catch((error) => {
                                console.log('Failed to send update modal to tab', tab.id, ':', error);
                            });
                        });
                    });
                } else {
                    // Hi·ªÉn th·ªã th√¥ng b√°o v·ªÅ phi√™n b·∫£n m·ªõi nh·∫•t n·∫øu kh√¥ng c√≥ c·∫≠p nh·∫≠t
                    if (updateInfo.latestVersion) {
                        showUpdateNotification(
                            'üìã Phi√™n b·∫£n m·ªõi nh·∫•t tr√™n GitHub', 
                            `${updateInfo.releaseName || `KimiZK-Translator v${updateInfo.latestVersion}`} - ƒêang s·ª≠ d·ª•ng phi√™n b·∫£n m·ªõi nh·∫•t`
                        );
                    }
                }
            }).catch(error => {
                console.error('Error checking updates on startup:', error);
            });
        } else {
            console.log('Update notifications are disabled');
        }
    });
}

// Ki·ªÉm tra c·∫≠p nh·∫≠t ƒë·ªãnh k·ª≥
function scheduleUpdateCheck() {
    console.log('=== Scheduling periodic update check ===');
    
    chrome.storage.local.get(['lastUpdateCheck', 'updateNotifications'], (result) => {
        const now = Date.now();
        const lastCheck = result.lastUpdateCheck || 0;
        const notificationsEnabled = result.updateNotifications !== false; // M·∫∑c ƒë·ªãnh b·∫≠t
        
        console.log('Periodic check - Notifications enabled:', notificationsEnabled);
        console.log('Periodic check - Last check time:', new Date(lastCheck));
        console.log('Periodic check - Time since last check:', now - lastCheck, 'ms');
        console.log('Periodic check - Update interval:', UPDATE_CHECK_INTERVAL, 'ms');
        
        // Ki·ªÉm tra n·∫øu ƒë√£ qua 6 gi·ªù k·ªÉ t·ª´ l·∫ßn check cu·ªëi
        if (now - lastCheck > UPDATE_CHECK_INTERVAL && notificationsEnabled) {
            console.log('Time to check for updates...');
            // L∆∞u th·ªùi gian check
            chrome.storage.local.set({ lastUpdateCheck: now });
            
            checkForUpdates().then(updateInfo => {
                console.log('Periodic update check result:', updateInfo);
                
                if (updateInfo.hasUpdate) {
                    console.log('Update available in periodic check:', updateInfo);
                    // G·ª≠i modal c·∫≠p nh·∫≠t ƒë·∫øn t·∫•t c·∫£ tabs
                    chrome.tabs.query({}, (tabs) => {
                        console.log('Found tabs for periodic check:', tabs.length);
                        tabs.forEach(tab => {
                            chrome.tabs.sendMessage(tab.id, {
                                action: "showUpdateModal",
                                updateInfo: updateInfo
                            }).catch((error) => {
                                console.log('Failed to send update modal to tab', tab.id, ':', error);
                            });
                        });
                    });
                }
            }).catch(error => {
                console.error('Error in periodic update check:', error);
            });
        } else {
            console.log('Not time for periodic update check yet');
        }
    });
}

// Ki·ªÉm tra c·∫≠p nh·∫≠t t·ª´ GitHub
async function checkForUpdates() {
    try {
        console.log('Checking for updates... Current version:', CURRENT_VERSION);
        const response = await fetch(GITHUB_RELEASES_URL);
        if (!response.ok) throw new Error('Failed to fetch release info');
        
        const releaseData = await response.json();
        const latestVersion = releaseData.tag_name.replace('v', '');
        
        console.log('Latest version from GitHub:', latestVersion);
        
        // Lu√¥n tr·∫£ v·ªÅ th√¥ng tin phi√™n b·∫£n m·ªõi nh·∫•t t·ª´ GitHub
        console.log('Latest version from GitHub:', latestVersion);
        
        if (latestVersion !== CURRENT_VERSION) {
            console.log('Update available!');
            return {
                hasUpdate: true,
                currentVersion: CURRENT_VERSION,
                latestVersion: latestVersion,
                releaseNotes: releaseData.body,
                downloadUrl: releaseData.html_url,
                releaseName: releaseData.name || `KimiZK-Translator v${latestVersion}`,
                message: `üöÄ C√≥ phi√™n b·∫£n m·ªõi ${latestVersion} s·∫µn s√†ng c·∫≠p nh·∫≠t! ${releaseData.name || `KimiZK-Translator v${latestVersion}`} v·ªõi Auto-update, h·ªó tr·ª£ 13+ ng√¥n ng·ªØ, UI hi·ªán ƒë·∫°i, Manifest V3!`
            };
        } else {
            console.log('No update available - using latest version');
            return { 
                hasUpdate: false,
                currentVersion: CURRENT_VERSION,
                latestVersion: latestVersion,
                releaseName: releaseData.name || `KimiZK-Translator v${latestVersion}`,
                message: `‚úÖ ƒêang s·ª≠ d·ª•ng ${releaseData.name || `KimiZK-Translator v${latestVersion}`} - phi√™n b·∫£n m·ªõi nh·∫•t v·ªõi Auto-update, h·ªó tr·ª£ 13+ ng√¥n ng·ªØ, UI hi·ªán ƒë·∫°i, Manifest V3`
            };
        }
    } catch (error) {
        console.error('Error checking for updates:', error);
        return { 
            hasUpdate: false, 
            error: error.message,
            currentVersion: CURRENT_VERSION,
            message: "‚ùå Kh√¥ng th·ªÉ ki·ªÉm tra c·∫≠p nh·∫≠t: " + error.message
        };
    }
}

// Th·ª±c hi·ªán c·∫≠p nh·∫≠t t·ª± ƒë·ªông
async function performUpdate() {
    try {
        // L·∫•y th√¥ng tin release m·ªõi nh·∫•t
        const response = await fetch(GITHUB_RELEASES_URL);
        if (!response.ok) throw new Error('Failed to fetch release info');
        
        const releaseData = await response.json();
        const downloadUrl = releaseData.assets?.[0]?.browser_download_url;
        
        if (!downloadUrl) {
            throw new Error('No download URL found in release');
        }
        
        console.log('Downloading update from:', downloadUrl);
        
        // Download file extension m·ªõi
        const downloadResponse = await fetch(downloadUrl);
        if (!downloadResponse.ok) throw new Error('Failed to download update');
        
        const blob = await downloadResponse.blob();
        
        // T·∫°o URL cho blob
        const blobUrl = URL.createObjectURL(blob);
        
        // T·ª± ƒë·ªông c√†i ƒë·∫∑t extension m·ªõi
        try {
            // S·ª≠ d·ª•ng chrome.management API ƒë·ªÉ c√†i ƒë·∫∑t extension
            const installResult = await installExtensionFromBlob(blob);
            
            if (installResult.success) {
                            showUpdateNotification(
                'üéâ C·∫≠p nh·∫≠t th√†nh c√¥ng!', 
                `${releaseData.name || `KimiZK-Translator v${releaseData.tag_name}`} ƒë√£ ƒë∆∞·ª£c c·∫≠p nh·∫≠t th√†nh c√¥ng!`
            );
                
                // Reload extension sau khi c√†i ƒë·∫∑t
                setTimeout(() => {
                    chrome.runtime.reload();
                }, 2000);
                
                return { 
                    success: true, 
                    message: 'Update installed successfully',
                    newVersion: releaseData.tag_name
                };
            } else {
                throw new Error(installResult.error);
            }
            
        } catch (installError) {
            console.error('Installation failed:', installError);
            
            // Fallback: M·ªü tab download ƒë·ªÉ user c√†i ƒë·∫∑t th·ªß c√¥ng
            chrome.tabs.create({
                url: downloadUrl,
                active: true
            });
            
                    showUpdateNotification(
            'üì¶ T·∫£i v·ªÅ th√†nh c√¥ng!', 
            `${releaseData.name || `KimiZK-Translator v${releaseData.tag_name}`} ƒë√£ ƒë∆∞·ª£c t·∫£i v·ªÅ. Vui l√≤ng l√†m theo h∆∞·ªõng d·∫´n trong tab v·ª´a m·ªü ƒë·ªÉ c√†i ƒë·∫∑t phi√™n b·∫£n m·ªõi v·ªõi Auto-update, h·ªó tr·ª£ 13+ ng√¥n ng·ªØ, UI hi·ªán ƒë·∫°i, Manifest V3!`
        );
            
            return { 
                success: true, 
                message: 'Update downloaded successfully',
                downloadUrl: downloadUrl
            };
        }
        
    } catch (error) {
        console.error('Error performing update:', error);
        
        // Fallback: M·ªü trang releases ƒë·ªÉ user download th·ªß c√¥ng
        chrome.tabs.create({
            url: 'https://github.com/KimiZK-Dev/KimiZK-Translator/releases',
            active: true
        });
        
        showUpdateNotification(
            '‚ö†Ô∏è Kh√¥ng th·ªÉ t·∫£i t·ª± ƒë·ªông', 
            'ƒê√£ m·ªü trang GitHub Releases ƒë·ªÉ b·∫°n t·∫£i v·ªÅ v√† c√†i ƒë·∫∑t th·ªß c√¥ng. Phi√™n b·∫£n m·ªõi c√≥ Auto-update, h·ªó tr·ª£ 13+ ng√¥n ng·ªØ, UI hi·ªán ƒë·∫°i, Manifest V3!'
        );
        
        return { 
            success: false, 
            error: error.message,
            fallbackUrl: 'https://github.com/KimiZK-Dev/KimiZK-Translator/releases'
        };
    }
}

// H√†m c√†i ƒë·∫∑t extension t·ª´ blob
async function installExtensionFromBlob(blob) {
    return new Promise((resolve) => {
        try {
            // T·∫°o file reader ƒë·ªÉ ƒë·ªçc blob
            const reader = new FileReader();
            reader.onload = async function(e) {
                try {
                    // Chuy·ªÉn ƒë·ªïi blob th√†nh base64
                    const base64Data = e.target.result.split(',')[1];
                    
                    // S·ª≠ d·ª•ng chrome.management API ƒë·ªÉ c√†i ƒë·∫∑t
                    chrome.management.install({
                        data: base64Data,
                        callback: (result) => {
                            if (chrome.runtime.lastError) {
                                resolve({
                                    success: false,
                                    error: chrome.runtime.lastError.message
                                });
                            } else {
                                resolve({
                                    success: true,
                                    result: result
                                });
                            }
                        }
                    });
                } catch (error) {
                    resolve({
                        success: false,
                        error: error.message
                    });
                }
            };
            reader.readAsDataURL(blob);
        } catch (error) {
            resolve({
                success: false,
                error: error.message
            });
        }
    });
}

// Hi·ªÉn th·ªã th√¥ng b√°o c·∫≠p nh·∫≠t
function showUpdateNotification(title, message) {
    try {
        // Th·ª≠ t·∫°o notification v·ªõi icon
        chrome.notifications.create({
            type: 'basic',
            iconUrl: chrome.runtime.getURL('src/icons/icon128.png'),
            title: title,
            message: message
        }, (notificationId) => {
            if (chrome.runtime.lastError) {
                console.error('Notification with icon failed:', chrome.runtime.lastError);
                // Fallback: t·∫°o notification kh√¥ng c√≥ icon
                chrome.notifications.create({
                    type: 'basic',
                    title: title,
                    message: message
                }, (fallbackId) => {
                    if (chrome.runtime.lastError) {
                        console.error('Fallback notification failed:', chrome.runtime.lastError);
                    } else {
                        console.log('Fallback notification created successfully');
                    }
                });
            } else {
                console.log('Notification created successfully with icon');
            }
        });
    } catch (error) {
        console.error('Error creating notification:', error);
        // Final fallback: t·∫°o notification ƒë∆°n gi·∫£n nh·∫•t
        try {
            chrome.notifications.create({
                type: 'basic',
                title: title,
                message: message
            });
        } catch (finalError) {
            console.error('Final fallback notification failed:', finalError);
        }
    }
} 